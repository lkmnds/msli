## CALL THE GOD OF CODE

impr Internals : intr;
# import internal functions from msl.py

# declre intr as local for this file
intr = .local(intr);

.init(); # initialize interpreter functions

## INITIALIZE BASIC TYPES

int = .copy(intr.int)
cint = .copy(.c_newtype("n>i", null)) # can cause overflows etc.
clli = .copy(.c_newtype("n>lli", null))

cl long < int{
    f init(_, val){
        _.value = intr.int.generalize(val)
    }
    f _add(_, other){
        ret intr.int.g_add(_.value, other.value)
    }
    f _sub(_, other){
        ret intr.int.g_sub(_.value, other.value)
    }

    f _str(_){
        ret _.value # it is already a string
    }
}

array = .copy(intr.array)
list = .copy(array)

cl keymap < {
    f init(_){
        basekm.init(_)
    }
    f _len(_){
        ret len(_._km_vals)
    }
    f _get(_, key){
        ret _._baseget(key)
    }
    f _put(_, key, value){
        ret _._baseput(key)
    }
}

# since we need iterators before strings, I'll write them here
baseiter = .clcopy(intr.Iterator);

cl iter{
    f init(_, initval){
        _.val = []
        _.cursor = 0
        if(type(initval) == array){
            # work out initval and generate iterator
            # based on it
            del _.val # optimize and delete the earlier created list
            _.val = array
        }else if(type(initval) == keymap){
            _.val = pairs(keymap)
        }
    }
    f _next(_){
        v = .copy(_.val[cursor]) # so that v isn't deleted as referencing goes on
        _.cursor++

        # KILL HIM
        del _.val[cursor]
        ret v
    }
    f _del(){
        del _.val
        del _.cursor
    }
    f _gc_collect() not implemented;
}

# godstr: god of all strings, they are him
godstr = .copy(intr.godstring);
cstr = .copy(.c_newtype("n>s", null))
cunicode = .copy(.c_newtype("n>us", null))

godstr.set_base(cunicode);

cl unicode < godstr{
    f init(_, val){
        godstr.init(_, val);
        # godstr handles unicode for us
    }

    f _add(_, other){
        if(other == ''){
            #don't waste cycles adding a string to an empty one!
            ret _
        }else{
            ret godstr.concat(_, other)
        }
    }

    f _sub not implemented;

    f _mul(_, num){
        assert type(num) == 'number'
        return godstr.mul(_, num)
    }
}

str = .copy(unicode)

## COPYING STUFF

file = .copy(intr.fileobject);

Exception = .copy(intr.GeneralError);
Error = .copy(intr.GeneralError);
cl IOError < Error{
    f init(){
        Error.init(_)
    }
    f _call(){
        _.init()
    }
}

## FILE STUFF

f write(fileobj, data){
    if(data == null){
        data = fileobj
        fileobj = intr.stdout
    }
    ret intr.fwrite(fileobj, data)
}

f read(fileobj, data){
    if(data == null){
        data = fileobj
        fileobj = intr.stdin
    }
    ret intr.fread(fileobj, data)
}

## WRITING STUFF

f len(obj){
    if(obj.__len == f (){}){
        ret obj.__len() # return the object's own way of length
    }else if(isofcl(obj, "array")){
        # treat object as array and work out the length
        i = 0 # declare i as integer by default
        i.type = .newCType("i>lli", i) # change to long long int

        # loop through the object and done.
        while(obj[i] != null){ i++; }

        ret i;
    }else{
        send Exception:
            "Expected Iterator or array."
    }
}

# well, write strings to screen... isn't it?
f echo(string){
    # performance: convert string to C 'char'
    string = .c_cnv("cp->ca", string, len(string))
    for("char" in string.iter() : c){
        write(intr.stdout, c)
    }
}

# convert keymap to a {k,v} iterator
f pairs(kmp){
    kmp_iterator = iter()
    for(value in kmp : el){
        kmp_iterator._val.append(el)
    }
    return kmp_iterator
}

# export all symbols to global scope
.gs_export(.locals())


## CLEANING STUFF

.prg_init() # start purgatory

# init GC
.gc_start()
.gc_set(40) # threshold of life of object(in calls)

# put internal lib in purgatory
.purge(intr, "Internals")

# run GC. ALWAYS. FOR EVER.
.gc_run();

# if main function is already at global scope, run it
if(.g_scope("main") == f(){} && intr.run_main == true){
    .g_scope("main")();
}
